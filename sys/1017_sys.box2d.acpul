### 1017 sys.box2d
box2d
{
 static 0;
 kinematic 1;
 dynamic 2;

 bodyDef.DESCRIPTION { # info only (types, ranges...)
  type     {static;kinematic;dynamic;};
  position {x;y;};
  angle    0-380;
#  mass     kg;
  linear.velocity ;
  angular.velocity ;
  linear.damping ;
  angular.damping ;
  allow.sleep ;
  awake ;
  fixed.rotation ;
  bullet ;
  active ;
  gravity.scale 1.0;
 };
 reset
 # u0
  io(_0, 500300, 0,0,0,0);
 step
 # u0, dt, velocityIteractions, positionIteractions
  io(_0, 500301, _1,_2,_3,0);
 
 world {
 # u0, gravity(x,y)
  io(_0, 500302, _1,_2,0,0);
  
  draw
  # u0, world
   io(_0, 500321, _1,0,0,0);
 };

 # BODY [

 default.dynamic.body.info {
  type box2d.dynamic;
  x 0;
  y 0;
  angle 0;
  velocity.linear {x 0; y 0;};
  velocity.angular 0;
  damping.linear 0;
  damping.angular 0;
  allow.sleep 0;
  awake 0;
  fixed.rotation 0;
  bullet 0;
  active 1;
  gravity.scale 1;
 };

 default.static.body.info {
  _ default.dynamic.body.info;
  type box2d.static;
 };

 body.def.type.position.angle
 # u0, type, x,y, angle
  io(_0, 500303, _1, _2,_3, _4);
 body.def.velocity.linear.angular
 # u0, v(x,y), angle
  io(_0, 500304, _1,_2, _3, 0);
 body.def.damping.linear.angular.allowSleep.awake
 # u0, damping.v(x,y), damping.a, allowSleep, awake
  io(_0, 500305, _1, _2, _3, _4);
 body.def.fixed.rotation.bullet.active.gravity.scale
 # u0, fixedRotation, bullet, active, gravityScale 
  io(_0, 500306, _1, _2, _3, _4);

 body.def0 body.def.type.position.angle;
 body.def1 body.def.velocity.linear.angular;
 body.def2 body.def.damping.linear.angular.allowSleep.awake;
 body.def3 body.def.fixed.rotation.bullet.active.gravity.scale;

 body.create 
 # u0, world
  io(_0, 500307, _1, 0,0,0);

 box2d.body.create2 {
 # u0, world, info :: default.*.body.info -> body
  body.def.type.position.angle(u0, _2.type, _2.x,_2.y, _2.angle);
  body.def.velocity.linear.angular(u0, _2.velocity.linear.x,_2.velocity.linear.y, _2.velocity.angular);
  body.create(_0, _1);
 };

 # create ]

 body.group.add # body, group
 {
  io(_0, 500308, _1, _2, 0,0);
 };
 body.group.remove # body, group
 {
  io(_0, 500309, _1, _2,0,0);
 };
 body.data.values4 # data[4]
 {
  io(_0, 500310, _1, _2, _3, _4);
 };
 body.data.set # body, offset <data[4]>
 {
  io(_0, 500311, _1, _2, 0,0);
 };
 body.data.get # body, offset > data[offset]
 {
  io(_0, 500312, _1, _2, 0,0);
 };

 # position, angle [
 
 body.set.transform
 # u0, x,y, angle
 {
  io(_0, 500370, _1,_2, _3, 0);
 };
 body.get.position
 # u0 -> o0,o1
 {
  io(_0, 500371, _1, 0,0,0);
 };
 body.get.angle
 # u0
 {
  io(_0, 500372, _1, 0,0,0);
 };
 
 # position, angle ]
 # velocity [

 body.set.linear.velocity
 # u0, vx,vy
  io(_0, 500373, _1, _2,_3, 0);

 body.get.linear.velocity
 # u0 -> o0,o1
  io(_0, 500374, _1, 0,0,0);

 body.set.angular.velocity
 # u0, va
  io(_0, 500374, _1, _2, 0,0);

 body.get.angular.velocity
 # u0
  io(_0, 500375, _1, 0,0,0);

# velocity ]
# BODY ]
 # COLLISION [
  
 collision.group.rule # world, a, b, enableEvent
 {
  io(_0, 500320, _1, _2, _3, _4);
 };

 # COLLISION ]
 # SHAPE [

 # type:  
 polygon 0;
 circle 1;
 edge 2;
 chain 3;

 shape.create # type(polygon/circle/edge/chain)
 {
  io(_0, 500330, _1, 0,0,0);
 };
 shape.create.polygon shape.create(_0, box2d.polygon);
 shape.create.circle shape.create(_0, box2d.circle);
 shape.create.edge shape.create(_0, box2d.edge);
 shape.create.chain shape.create(_0, box2d.chain);

 shape.set.radius # shape, radius
 {
  io(_0, 500331, _1, _2, 0,0);
 };
 shape.polygon.box # shape, hx, hy
 {
  io(_0, 500332, _1, _2, _3, 0);
 };
 shape.polygon.box.a
 # shape, hx, hy, center[x,y], angle
 {
  io(_0, 500333, _1, _4, _5, _6);
  io(_0, 500334, _1, _2, _3, 0);
 };
 shape.polygon.vertices
 # shape, vertecies[mem:offset], size
 {
  io(_0, 500335, _1, _2,_3, _4);
 };
 shape.edge.v0.v1
 # shape, v0[x,y], v1[x,y]
 {
  io(_0, 500336, _2,_3, _4,_5);
  io(_0, 500337, _1, 0,0,0);
 };
 shape.chain.create.loop
 # shape, vertecies[mem:offset], size
 {
  io(_0, 500338, _1, _2,_3, _4);
 };
 shape.chain.create.chain
 # shape, vertecies[mem:offset], size
 {
  io(_0, 500339, _1, _2,_3, _4);
 };
 shape.chain.set.prev.vertex
 # shape, vertex[x,y]
 {
  io(_0, 500340, _1, _2,_3, 0);
 };
 shape.chain.set.next.vertex
 # shape, vertex[x,y]
 {
  io(_0, 500341, _1, _2,_3, 0);
 };

 # SHAPE ]
 # FIXTURE [

 fixture.def
 # friction, restitution, density, isSensor
 {
  io(_0, 500350, _1, _2, _3, _4);
 };
 fixture.create
 # body, shape
 {
  io(_0, 500351, _1, _2, 0,0);
 };

 # FIXTURE ]
};
